# primaryWebserver
# Web服务器

Linux + C++开发

## 服务器功能：



## Socket编程：

传输层，通过TCP三次握手连接。绑定IP地址和端口号。

### 服务器端连接函数：

1. listen()：监听客户端；
2. accept()：来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。

### 客户端发起连接函数：

1. connect()：发起连接。

### 维护队列：

在完成TCP三次握手的队列中，accept()一个Socket，C/S通过其进行read()&write()。

## 多Socket：

TCP 连接是四元组唯一确认的，这个四元组就是：**本机IP, 本机端口, 对端IP, 对端端口**。服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。**最大 TCP 连接数 = 客户端 IP 数×客户端端口数**。

内存限制 + 进程读文件限制 + 带宽限制，无法满足太多的Socket。

### 多进程模式：

![](D:\college\University courses\Computer network\Web服务器\1.jpg)

上下文切换复杂。

### 多线程模式：

![](D:\college\University courses\Computer network\Web服务器\2.png)

队列需要加线程锁。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，开销巨大。

### I/O multiplexing：

elect/poll/epoll 内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 O(logn)，通过对这棵黑红树进行操作，这样就不需要像 select/poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。

第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，**只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。**

## 项目内容：

利用epoll复用技术实现对监听socket（listenfd）和连接socket（客户请求连接之后的socket）的同时监听。I/O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，所以为提高效率，这部分通过线程池来实现并发，为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。

## 多线程锁：

实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.

RALL机制：封装sem而不直接使用<semaphore.h>提供的结构体，是为了完成资源与变量生命周期的绑定。

①sem

sem 信号量是一种特殊的变量，访问具有**原子性**， 用于解决进程或线程间共享资源引发的同步问题。

线程对 sem 信号量可以有以下两种操作：

- 等待信号量
  当信号量值为 0 时，程序等待；当信号量值大于 0 时，信号量减 1，程序继续运行。
- 发送信号量
  将信号量值加 1

②locker

pthread使用分为三个部分：分叉，运行，合并

![](D:\college\University courses\Computer network\Web服务器\4.jpg)

设计进程锁，提供lock，unlock等函数。

③cond

条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.条件变量给多个线程提供了一个会合的场所

一般pthread_cond_t，会搭配pthread_mutex_t 一起使用的， 因为线程间通信时操作共享内存时，需要用到锁。当锁住的共享变量发生改变时，可能需要通知相应的线程（因为可能该共享变量涉及到多个线程），这时就需要用到pthread_cond_t这种条件变量来精准的通知某个或几个线程， 让他们执行相应的操作。

只使用mutex时，对于一个共享变量的改变是未知的，只能保证变量在一方使用时另一方不使用。使用cond则可以在一定时刻阻塞某一个线程，使其必须等待另一个线程完成共享变量的改变才可以继续进行。

1.  等待条件变量满足； 
2.  把获得的锁释放掉；（注意：1，2两步是一个原子操作） 	当然如果条件满足了，那么就不需要释放锁。所以释放锁这一步和等待条件满足一定是一起执行（指原子操作）。 
3.  pthread_cond_wait()被唤醒时，它解除阻塞，并且尝试获取锁（不一定拿到锁）。因此，一般在使用的时候都是在一个循环里使用pthread_cond_wait()函数，因为它在返回的时候不一定能拿到锁。

### 处理模式：（主线程&工作线程）

- Reactor模式：主线程只负责监听文件描述符上是否有事件发生及通知工作线程，将socket可读可写事件放入请求队列，工作线程完成读写数据、接受新连接及处理客户请求。(需要区别读和写事件)
- Proactor模式：主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程负责业务逻辑（给予相应的返回url），如处理客户请求。

![](D:\college\University courses\Computer network\Web服务器\3.bmp)

同步线程用于处理客户逻辑，异步线程用于处理I/O事件，异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中，请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

使用主线程监听所有的Socket事件，当有新的事件出现，在epoll内核中记录，封装Socket事件到请求队列，等待工作线程进行处理。

## 半同步线程池：

线程池是一种利用池化技术思想来实现的线程管理技术，主要是为了复用线程、便利地管理线程和任务、并将线程的创建和任务的执行解耦开来。我们可以创建线程池来复用已经创建的线程来降低频繁创建和销毁线程所带来的资源消耗。

同步I/O模拟proactor模式，将主线程和工作线程完全解耦，通过请求队列进行调度。

定义线程池类threadpool：

线程池包括成员变量请求队列，线程数组，以及对于请求队列的互斥锁locker以及sem作为读写同步信号量。

定义泛型，主要针对线程池中的请求队列，可能在其中涉及不同的事件。

主要的方法有：

①构造方法，即通过线程数量创建pthread_t数组，在逐个create，初始化一个请求队列。

②析构方法，释放线程数组的内存。

③append，向请求队列中放入一个事件，注意要对队列使用锁。

④run，从非空的请求队列中获取一个事件，一直循环运行，执行该事假提供的相应函数。

⑤work，静态成员函数，目的是对于pthread_create传入的静态函数。

pthread_detach

**线程分离状态：**指定该状态，线程主动与主控线程断开关系。线程结束后（不会产生僵尸线程），其退出状态不由其他线程获取，而直接自己自动释放（自己清理掉PCB的残留资源）。网络、多线程服务器常用。

## HTTP处理：

epoll:

- EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
- EPOLLOUT：表示对应的文件描述符可以写
- EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
- EPOLLERR：表示对应的文件描述符发生错误
- EPOLLHUP：表示对应的文件描述符被挂断；
- EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的
- EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里

struct epoll_event {
	__uint32_t events; /* Epoll events */
	epoll_data_t data; /* User data variable */
};

**Socket：**

```cpp
struct sockaddr {

　　unsigned short sa_family; /* 地址家族, AF_xxx */

　　char sa_data[14]; /*14字节协议地址*/

};
```

```cpp
struct sockaddr_in {

　　short int sin_family; /* 通信类型 */

　　unsigned short int sin_port; /* 端口 */

　　struct in_addr sin_addr; /* Internet 地址 */

　　unsigned char sin_zero[8]; /* 与sockaddr结构的长度相同*/

};
```

sin_addr存储4字节的IP地址，

流式Socket（STREAM）：是一种面向连接的Socket，针对于面向连接的TCP服务应用，安全，但是效率低；

数据报式Socket（DATAGRAM）：是一种无连接的Socket,对应于无连接的UDP服务应用.不安全(丢失,顺序混乱,在接收端要分析重排及要求重发),但效率高.

服务器端：

申请一个socket 绑定到一个IP地址和一个端口上 开启侦听，等待连接

socket()函数：

### bind()函数：

网络字节顺序，也称为大端字节序，是一种在网络通信中使用的字节序表示方式。在网络中，不同的计算机可能使用不同的字节序，因此为了确保数据的正确传输和解析，需要将数据转换为统一的字节序。

网络字节顺序要求将数据的高位字节存储在内存的低地址处，低位字节存储在高地址处，这与大多数主机的字节序是相反的。具体而言，网络字节顺序使用大端字节序（Big-Endian），其中最高有效字节（Most Significant Byte，MSB）在最低的内存地址，最低有效字节（Least Significant Byte，LSB）在最高的内存地址。

客户端： 申请一个socket 连接服务器（指明IP地址和端口号）

服务器端接到连接请求后，产生一个新的socket(端口大于1024）与客户端建立连接并进行通讯，原监听socket继续监听。

**http请求报文：**

HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。请求分为两种，GET和POST，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。

http响应报文：

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

http报文处理过程：

①首先客户机发送http连接请求，有I/O处理单元（主线程）生成http对象存入缓存，插入请求队列等待线程池中的工作线程进行处理。





1. 添加epoll事件处理

包括addfd，将文件加入epoll的管理范围，removefd，从管理中移除。使用epoll_ctl进行控制。

2. 初始化处理外部连接



**定时器：**

是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。

**难点是文件、并发、触发和定时。**

EPOLLIN等是一种规定的触发类型

